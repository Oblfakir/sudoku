Алгоритм построим следующим образом:

Вход: Поле головоломки Судоку, часть клеток которого заполнена;
Выход: Полностью заполненное поле или пустое поле, если решения нет;
Начало
    Пока возможно:
        Для каждой клетки проверяем выполнение условий на уникальность в ряду, столбце и блоке:
            Если для какой-то клетки подходящей цифры не нашлось, то завершаем работу алгоритма (решения нет);
            Если существует единственная подходящая цифра, то заполняем клетку соответствующим образом;
        Если все клетки заполнены, то завершаем цикл и возвращаем найденное решение;
        Иначе если ни одну клетку за проход заполнить не удалось, то завершаем цикл;
    Для клетки с минимальным количеством вариантов:
        Пробуем ставить каждую цифру по порядку и рекурсивно решать получившиеся Судоку;
        Если решение было найдено, то возвращаем его;
Конец.
Представленная логика достаточно проста и понятна. Сначала мы пытаемся заполнить клетки, для которых все однозначно. Для этого мы используем ограничения на уникальность по рядам, столбцам и блокам. Если Судоку некорректное, то на какой-то из итераций выявится клетка, для которой вообще нет допустимых вариантов. В этом случае дальше нам делать нечего.

Для наиболее простых Судоку на этом алгоритм можно было бы и закончить. Решение бы уже нашлось. Но для более сложных не так все легко. В них появятся клетки, для которых нет однозначных вариантов. Поэтому нам приходится работать с вероятностями. Конечно, есть достаточно сложные алгоритмы, которые бы существенно могли сократить перебор, но они также сложнее в реализации. Поэтому мы используем метод грубой силы.

Но чтобы не делать лишних действий, мы выбираем для перебора такие клетки, у которых количество возможных вариантов оказывается наименьшим. А затем устанавливаем каждый из этих вариантов и пробуем решать то Судоку, которое получится, тем же самым алгоритмом рекурсивно. Если предположение было сделано неверно, то на каком-то из шагов рекурсии найдется клетка, у которой не будет возможных решений, после чего мы перейдем к другому варианту. И так будем пробовать до тех пор, пока все не сойдется.

import copy
import time

class SudokuSolver:
    def solve( puzzle ):
        solution = copy.deepcopy( puzzle )
        if SudokuSolver.solveHelper( solution ):
            return solution
        return None

    def solveHelper( solution ):
        minPossibleValueCountCell = None
        while True:
            minPossibleValueCountCell = None
            for rowIndex in range( 9 ):
                for columnIndex in range( 9 ):
                    if solution[ rowIndex ][ columnIndex ] != 0:
                        continue
                    possibleValues = SudokuSolver.findPossibleValues( rowIndex, columnIndex, solution )
                    possibleValueCount = len( possibleValues )
                    if possibleValueCount == 0:
                        return False
                    if possibleValueCount == 1:
                        solution[ rowIndex ][ columnIndex ] = possibleValues.pop()
                    if not minPossibleValueCountCell or \
                       possibleValueCount < len( minPossibleValueCountCell[ 1 ] ):
                        minPossibleValueCountCell = ( ( rowIndex, columnIndex ), possibleValues )
            if not minPossibleValueCountCell:
                return True
            elif 1 < len( minPossibleValueCountCell[ 1 ] ):
                break
        r, c = minPossibleValueCountCell[ 0 ]
        for v in minPossibleValueCountCell[ 1 ]:
            solutionCopy = copy.deepcopy( solution )
            solutionCopy[ r ][ c ] = v
            if SudokuSolver.solveHelper( solutionCopy ):
                for r in range( 9 ):
                    for c in range( 9 ):
                        solution[ r ][ c ] = solutionCopy[ r ][ c ]
                return True
        return False

    def findPossibleValues( rowIndex, columnIndex, puzzle ):
        values = { v for v in range( 1, 10 ) }
        values -= SudokuSolver.getRowValues( rowIndex, puzzle )
        values -= SudokuSolver.getColumnValues( columnIndex, puzzle )
        values -= SudokuSolver.getBlockValues( rowIndex, columnIndex, puzzle )
        return values

    def getRowValues( rowIndex, puzzle ):
        return set( puzzle[ rowIndex ][ : ] )

    def getColumnValues( columnIndex, puzzle ):
        return { puzzle[ r ][ columnIndex ] for r in range( 9 ) }

    def getBlockValues( rowIndex, columnIndex, puzzle ):
        blockRowStart = 3 * ( rowIndex // 3 )
        blockColumnStart = 3 * ( columnIndex // 3 )
        return {
            puzzle[ blockRowStart + r ][ blockColumnStart + c ]
                for r in range( 3 )
                for c in range( 3 )
        }

def printPuzzle( puzzle ):
    for row in puzzle:
        print( row )


puzzle = [
    [ 0, 0, 0, 0, 6, 0, 7, 0, 0 ],
    [ 0, 5, 9, 0, 0, 0, 0, 0, 0 ],
    [ 0, 1, 0, 2, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 1, 0, 0, 0, 0, 0 ],
    [ 6, 0, 0, 5, 0, 0, 0, 0, 0 ],
    [ 3, 0, 0, 0, 0, 0, 4, 6, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
    [ 0, 0, 0, 0, 0, 0, 0, 9, 1 ],
    [ 8, 0, 0, 7, 4, 0, 0, 0, 0 ]
]

printPuzzle( puzzle )
print()

startTime = time.clock()
solution = SudokuSolver.solve( puzzle )
if solution: printPuzzle( solution )

print()
print( time.clock() - startTime, "sec" )


#include <iostream>

#include <QVector>
#include <QSet>
#include <QTime>

typedef QVector< QVector< int > > Puzzle;
typedef QSet< int > Values;

class SudokuSolver {
public:
    static Puzzle solve( const Puzzle& puzzle ) {
        Puzzle solution = puzzle;
        if( solveHelper( &solution ) ) {
            return solution;
        }
        return Puzzle();
    }

    static bool solveHelper( Puzzle* solution ) {
        int minRow = -1;
        int minColumn = -1;
        Values minValues;
        forever {
            minRow = -1;
            for( int rowIndex = 0; rowIndex < 9; ++rowIndex ) {
                for( int columnIndex = 0; columnIndex < 9; ++columnIndex ) {
                    if( ( *solution )[ rowIndex ][ columnIndex ] != 0 ) {
                        continue;
                    }
                    Values possibleValues = findPossibleValues( rowIndex, columnIndex, *solution );
                    int possibleVaueCount = possibleValues.count();
                    if( possibleVaueCount == 0 ) {
                        return false;
                    }
                    if( possibleVaueCount == 1 ) {
                        ( *solution )[ rowIndex ][ columnIndex ] = *possibleValues.begin();
                    }
                    if( minRow < 0 || possibleVaueCount < minValues.count() ) {
                        minRow = rowIndex;
                        minColumn = columnIndex;
                        minValues = possibleValues;
                    }
                }
            }
            if( minRow == -1 ) {
                return true;
            } else if( 1 < minValues.count() ) {
                break;
            }
        }
        for( auto v : minValues ) {
            Puzzle solutionCopy = *solution;
            solutionCopy[ minRow ][ minColumn ] = v;
            if( solveHelper( &solutionCopy ) ) {
                *solution = solutionCopy;
                return true;
            }
        }
        return false;
    }

    static Values findPossibleValues( int rowIndex, int columnIndex, const Puzzle& puzzle ) {
        Values values;
        for( int i = 1; i < 10; ++i ) {
            values << i;
        }
        values -= getRowValues( rowIndex, puzzle );
        values -= getColumnValues( columnIndex, puzzle );
        values -= getBlockValues( rowIndex, columnIndex, puzzle );

        return values;
    }

    static Values getRowValues( int rowIndex, const Puzzle& puzzle ) {
        return Values::fromList( puzzle[ rowIndex ].toList() );
    }

    static Values getColumnValues( int columnIndex, const Puzzle& puzzle ) {
        Values values;
        for( int r = 0; r < 9; ++r ) {
            values << puzzle[ r ][ columnIndex ];
        }
        return values;
    }

    static Values getBlockValues( int rowIndex, int columnIndex, const Puzzle& puzzle ) {
        Values values;
        int blockRowStart = 3 * ( rowIndex / 3 );
        int blockColumnStart = 3 * ( columnIndex / 3 );
        for( int r = 0; r < 3; ++r ) {
            for( int c = 0; c < 3; ++c ) {
                values << puzzle[ blockRowStart + r ][ blockColumnStart + c ];
            }
        }
        return values;
    }
};

void printPuzzle( const Puzzle& puzzle ) {
    for( auto row : puzzle ) {
        for( auto v : row ) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    }
}

int main() {
    Puzzle puzzle = {
        { 0, 0, 0, 0, 6, 0, 7, 0, 0 },
        { 0, 5, 9, 0, 0, 0, 0, 0, 0 },
        { 0, 1, 0, 2, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 1, 0, 0, 0, 0, 0 },
        { 6, 0, 0, 5, 0, 0, 0, 0, 0 },
        { 3, 0, 0, 0, 0, 0, 4, 6, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 9, 1 },
        { 8, 0, 0, 7, 4, 0, 0, 0, 0 }
    };

    printPuzzle( puzzle );
    std::cout << std::endl;

    QTime time;
    time.start();
    Puzzle solution = SudokuSolver::solve( puzzle );
    if( !solution.isEmpty() ) printPuzzle( solution );

    std::cout << std::endl;
    std::cout << time.elapsed() / 1000.0 << " sec" << std::endl;

    return 0;
}


--------

Есть несколько видов перестановок, выполнив которые таблица Судоку останется в допустимом состоянии.
К ним относятся:

Транспонирование всей таблицы — столбцы становятся строками и наоборот (transposing)
Обмен двух строк в пределах одного района (swap_rows_small)
Обмен двух столбцов в пределах одного района (swap_colums_small)
Обмен двух районов по горизонтали (swap_rows_area)
Обмен двух районов по вертикали (swap_colums_area)